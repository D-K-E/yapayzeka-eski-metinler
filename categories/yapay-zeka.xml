<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Yapay Zeka, Derin Öğrenim ve Eski Metinler Üzerine Notlar (yapay-zeka ile ilgili yazılar)</title><link>https://d-k-e.github.io/yapayzeka-eski-metinler/</link><description></description><atom:link rel="self" type="application/rss+xml" href="https://d-k-e.github.io/yapayzeka-eski-metinler/categories/yapay-zeka.xml"></atom:link><language>tr</language><copyright>Contents © 2017 &lt;a href="mailto:kaaneraslan@gmail.com"&gt;Kaan Eraslan&lt;/a&gt; </copyright><lastBuildDate>Mon, 31 Jul 2017 15:01:44 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Dillerarası Bilgi Alım Teknikleri Üzerine Notlar - 1</title><link>https://d-k-e.github.io/yapayzeka-eski-metinler/posts/dillerarasi-bilgi-alim-teknikleri-uzerine-notlar-1/</link><dc:creator>Kaan Eraslan</dc:creator><description>&lt;div&gt;&lt;p&gt;Merhaba Arkadaşlar,&lt;/p&gt;
&lt;div class="contents topic" id="contents"&gt;
&lt;p class="topic-title first"&gt;Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/dillerarasi-bilgi-alim-teknikleri-uzerine-notlar-1/#bilgi-alimda-karsilasilan-sorunlar" id="id1"&gt;Bilgi Alımda Karşılaşılan Sorunlar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/dillerarasi-bilgi-alim-teknikleri-uzerine-notlar-1/#bilgi-alim-yontemlerinin-unsurlari" id="id2"&gt;Bilgi Alım Yöntemlerinin Unsurları&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;Bu yazı dizisinde dillerarası bilgi alım tekniklerine değineceğim. Kullandığım temel kaynak: Nie, Jian-Yun, Cross-Language Information Retrieval, Synthesis Lectures in Human Language Technologies, 8 (2010).
Internette kendisini bulmak mümkün.&lt;/p&gt;
&lt;p&gt;Önce konuya bir giriş niteliğinde olması için genel bilgi alım yöntemlerinin uygulama alanları, karşılaşılan sorunlar ve bu sorunlara cevap niteliğinde gelen modellerden bahsedeceğim.&lt;/p&gt;
&lt;div class="section" id="bilgi-alimda-karsilasilan-sorunlar"&gt;
&lt;h2&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/dillerarasi-bilgi-alim-teknikleri-uzerine-notlar-1/#bilgi-alimda-karsilasilan-sorunlar"&gt;Bilgi Alımda Karşılaşılan Sorunlar&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Bilgi alım yöntemleri, adı üstünde, ulaşmak istediğiniz bilgiyi size sunmaya çalışır.
Sayısal ortamda gerçekleştirilen bir bilgi alım sürecinin kabaca iki ana unsuru var:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Bilgi ihtiyacını temsil eden&lt;/li&gt;
&lt;li&gt;Bilgi ihtiyacına cevap veren&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bu ikisinin ne olduğu ve aralarındaki ilişkinin nasıl kurulduğu, daha doğrusu ne olduğuna bağlı olarak nasıl kurulduğu, bilgi alımda yöntemlerinin temel uygulama alanlarını ve ilgilendiği sorunları oluşturuyor.&lt;/p&gt;
&lt;p&gt;Bir bilgi alım problemi örneği verelim:&lt;/p&gt;
&lt;p&gt;Diyelim sevdiğiniz bir müzisyenin örneğin Emiltan Erten'in ya da Müşfik Can Müftüoğlunun bir parçasını dinlemek istediniz.
Ya da tatildesiniz, örneğin Kaş'ta, ve dalış yapmak istiyorsunuz, sizinle dalan hocanın adı aklınızda, Anıl Bozkırlı, tekne de aklınızda naturablue, ama teknenin kalkış saatlerini hatırlamıyorsunuz.
Elinizde parçanın adı var, müzisyenin adı var. İşte bunar bilgi ihtiyacınızı temsil edenler, dinlemek istediğiniz parçaysa bilgi ihtiyacınıza cevap veren, ya da teknenin saatleri bilgi ihtiyacınıza cevap veren.&lt;/p&gt;
&lt;p&gt;Daha aykırı bir örnek verelim:&lt;/p&gt;
&lt;p&gt;Bir şarkı bestelediniz, çok tuttu.
Öyle ki başka insanlar sizden telif almadan sağda solda parçanızı çalmaya ve hatta kendi parçalarıymış gibi pazarlamaya başladılar.
Siz bu insanları dava etmek istiyorsunuz. Bu senaryoda bilgi ihtiyacını temsil eden sizin parçanız, bilgi ihtiyacına cevap verense diğer insanların parçaları.
Bu senaryoda gerçekleşecek olan şey şu. Bir arama motoruna kendi parçanızı yükleyeceksiniz, o da size sizin parçalarınıza benzer parçaların listesini verecek.&lt;/p&gt;
&lt;p&gt;Geneli itibariyle bilgi alım süreçleri ve metodları her ne kadar metin dışındaki aracılara da uygulanabiliyor olsa da, genel uygulama alanı metindir, yani genelde bilgi ihtiyacını temsil eden ve ona cevap veren uzunluğu değişebilir olmak kaydıyla bir karakter zinciridir.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bilgi-alim-yontemlerinin-unsurlari"&gt;
&lt;h2&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/dillerarasi-bilgi-alim-teknikleri-uzerine-notlar-1/#bilgi-alim-yontemlerinin-unsurlari"&gt;Bilgi Alım Yöntemlerinin Unsurları&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Kabaca bir bilgi alım sürecinde etkin olan beş unsur vardır:&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;Belge derlemi&lt;/dt&gt;
&lt;dd&gt;Belge derlemi genellikle bilgi ihtiacına cevap vermesi beklenen belgelerin toplamından oluşur. Bu örneğin bir arama motoru için, internetteki sayfalardır.&lt;/dd&gt;
&lt;dt&gt;Sorgu&lt;/dt&gt;
&lt;dd&gt;Bu bir kelime de olabilir, bir belge de, bir cümle de. Bilgi ihtiyacını arayan failin bilgi ihtiyacına verene ulaşmak için kullandığı aracıdır. Örneğin, ulaşmak istediğiniz sayfanın çıkması için arama motoruna yazdığınız kelimeler.&lt;/dd&gt;
&lt;dt&gt;Dizinleme&lt;/dt&gt;
&lt;dd&gt;Bu belge ve sorgu için belge bir süreçtir. Genellikle belgenin ve sorgunun temsil şeklinin değiştirilmesi sayesinde olur. Örneğin, girdiğiniz sorguyu, girerken kullandığınız kelimelerin sıklığı ve sırası olarak temsil edebilirsiniz, bu derleminizdeki belgeler içinde geçerli.&lt;/dd&gt;
&lt;dt&gt;Benzerlik Notu&lt;/dt&gt;
&lt;dd&gt;Sorgu ve belge arasındaki benzerliğin ne kadar olduğunu hesaplamaya yarayan algoritmalar sonucunda ortaya çıkan nottur. Genellikle, bilgi ihtiyacına cevap verenlerin sıraya konmasında kullanılır.&lt;/dd&gt;
&lt;dt&gt;Geri Bildirim&lt;/dt&gt;
&lt;dd&gt;Bilgi ihtiyacının karşılanması adına sunduğunuz belgelerin ne kadar ilgili olduğuna dair kullanıcıların yaptığı geri dönüştür. Pratikte kullanıcılar nadiren böyle bir sürece dahil olurlar. Bu yüzden genelde &lt;em&gt;yalancı ilgililik geri bildirimleri&lt;/em&gt; kullanırlar. Bu da tıklanan tepedeki belgelerin daha ilgili olduğunu varsaymak şeklinde gerçekleşir.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Bu yazıyı burada bitiriyorum, zira bundan sonra gelen konu bilgi alım modelleri ve başlı başına bir yazı olmayı hak ediyor.&lt;/p&gt;
&lt;p&gt;Sağlıcakla,&lt;/p&gt;
&lt;p&gt;Kaan&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>bilgi-alım</category><category>mathjax</category><category>yapay-zeka</category><guid>https://d-k-e.github.io/yapayzeka-eski-metinler/posts/dillerarasi-bilgi-alim-teknikleri-uzerine-notlar-1/</guid><pubDate>Mon, 17 Jul 2017 12:48:38 GMT</pubDate></item><item><title>Makine Öğrenimine Hazırlık 2.1 Doğrusal Cebir 6</title><link>https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-6/</link><dc:creator>Kaan Eraslan</dc:creator><description>&lt;div&gt;&lt;p&gt;Merhaba Arkadaşlar,&lt;/p&gt;
&lt;p&gt;Bu yazıda &lt;span class="math"&gt;\(Ak=u\)&lt;/span&gt; denklem sistemi hangi durumlarda &lt;span class="math"&gt;\(A^{-1}\)&lt;/span&gt; ile çözülebilir sorusuna bir yanıt vereceğim.
Bundan önceki yazılar boyunca, özellikle Doğrusal Cebir 3-5 arasında bu sorunun çözümünde kullanılacak kavramsal alt yapıyı vermeye çalıştım.
Bildiğiniz gibi bu yazı dizisini aslında makine öğreniminde ve daha sonrasında derin öğrenimde karşımıza çıkacak algoritmaların matematiksel temellerini anlayabilmemiz için yazıyorum.
Eğer makine öğrenimine yeni başlıyorsanız, bu yazı dizisinin &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-1/"&gt;ilk bölümünden&lt;/a&gt; başlamanızı tavsiye ederim.
Eğer çok çok yeniyseniz ve "Makine Öğrenimi Nedir, Derin Öğrenim Nedir ?", gibi sorulara cevap bulmaya geldiyseniz, bunun için üç bölümlük bu konulara değinen &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/"&gt;ilk yazı dizisini&lt;/a&gt; tavsiye ederim.&lt;/p&gt;
&lt;p&gt;Denklemimizdeki elemanları hatırlayalım: &lt;span class="math"&gt;\(A{\in}{\mathbb{R}}^{mxp}\)&lt;/span&gt;, A bir &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-1/#dizeyler"&gt;dizey&lt;/a&gt;; &lt;span class="math"&gt;\(k{\in}{\mathbb{R}^p}\)&lt;/span&gt;, k &lt;em&gt;bilinmeyen&lt;/em&gt; bir &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-1/#yoneyler"&gt;yöney&lt;/a&gt;; &lt;span class="math"&gt;\(u{\in}{\mathbb{R}^p}\)&lt;/span&gt;, u &lt;em&gt;bilinen&lt;/em&gt; bir yöneydir.
Kısaca "k"'nın değerini bulmaya çalışıyoruz.
Bunun için &lt;span class="math"&gt;\(A^{-1}\)&lt;/span&gt; ters dizeyini kullanarak şu çözüme gitmiştik:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
Ak=u
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
A^{-1}Ak = uA^{-1}
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
I_nk=uA^{-1}
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
k=uA^{-1}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Bu hatırlatmayı burada bırakalım.
Daha detaylı bir açıklama için, &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-3/#ters-dizey"&gt;buraya&lt;/a&gt; bakabilirsiniz.&lt;/p&gt;
&lt;p&gt;Burada "k"'nın bir çözümünün olması, "u"'nun, "k" ve "A"'nın çarpımından oluştuğu düşünülürse, A'nın &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/#dogrusal-aralik"&gt;sütun alanında&lt;/a&gt;  olmasına bağlıdır.
Bu durumda, yine aynı işlemde gerçekleştirilen &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-2/#yoney-carpimi"&gt;nokta çarpımı&lt;/a&gt; dolayısıyla &lt;span class="math"&gt;\(u{\in}{\mathbb{R}^m}\)&lt;/span&gt; halini varsayar.
Kısaca "u" yöneyinin elemanları "A" dizeyinin katsayı yöneyi ile çarpılıp toplanmasından oluştuğundan ve katsayı yöneyi bilinmeyen olduğundan, "u"nun elemanlarının A yöneyinin satırlarının elemanlarının ait olduğu kümeye ait olması beklenir.
Katsayı yöneyinin bilinmeyen olması durumu, denklemin çözülebilmesi için "A"'nın sütun alanının &lt;span class="math"&gt;\({\mathbb{R}^m}\)&lt;/span&gt; kümesini kapsamasını gerektirir, zira eğer herhangi bir nokta sütun alanından eksik ise "u" nun o nokta için alabileceği değerin çözümü yoktur.
Daha önceki yazılarımda dizey çarpımı işleminin nasıl yapıldığına değinmiştim, ama burada gözünüzde canlandıramadıysanız bir kere daha belirteyim.
A dizeyi ile "k" yöneyini çarpmak demek, A dizeyinin satırlarının her birinde bulunan elemanları "k" yöneyinin satıra denk gelen elemanıyla çarparak, dizey satırını kendi içinde toplamak demek olduğundan, bu işlem sonucu oluşacak "u" yöneyinin ilgili elemanının da A dizeyinin satırlarını kapsayan kümeye dahil olması beklenir, çünkü en nihayetinde yapılan şey A dizeyinin bir satırını katsayı yöneyinin sayıllarıyla çarpıp toplamak.&lt;/p&gt;
&lt;p&gt;Şimdi, "m" A'nın satır sayısını temsil ettiğine göre, ve yukarıda belirttiğim &lt;span class="math"&gt;\(u{\in}{\mathbb{R}^m}\)&lt;/span&gt; durumu da geçerli olduğuna göre, şu göstergeyi de kabul etmek durumundayız, &lt;span class="math"&gt;\(p {\ge} m\)&lt;/span&gt;.
Neden ? Çünkü A dizeyinin k yöneyi ile çarpımı sonucu oluşacak olanın p sütun sayısına sahip olacağını dizey çarpımı işleminin yapısı gereği olduğunu biliyoruz.
Yine aynı şekilde eğer "u" yöneyinin elemanlarının &lt;span class="math"&gt;\({\mathbb{R}^m}\)&lt;/span&gt; kümesine dahil olduklarını da biliyoruz.
O halde "p" "m"'den küçük olamaz, çünkü eğer olursa "u" yöneyinin elemanlarından biri A dizeyinin sütun alanın dışında kalır.
Bunun getireceği sonuç "u"'yöneyinin denklem sisteminin her bileşimi için sonucunun garanti olmaması olacaktır.&lt;/p&gt;
&lt;p&gt;Ancak şunu biliyoruz, doğrusal bağımlılık gösteren yöneyler, aslında tek bir yöney ile temsil edilebiliyorlar.
Dolayısıyla sütun alanına yaptıkları bir etki yok. Bu şu demek, &lt;span class="math"&gt;\(p {\ge} m\)&lt;/span&gt; şartına bir de, bir veya daha fazla m boyutlu doğrusal bağımsızlık gösteren denklemler kümesi barındırmak eklendi.
Sorulabilecek makul soru şu, neden "p" "m"'den büyük olabiliyorken, barındırılabilecek bağımsız denklemler kümesi "m" üzerinden birimleniyor ?
Bunun sebebi şu, yukarıda belirttiğim gibi esasında &lt;span class="math"&gt;\(p {\ge} m\)&lt;/span&gt; bir gösterge, yani ilk elde baktığınızda size bir fikir verecek, kabaca eleme yapabilmenizi sağlayacak bir belirti.
Doğrusal bağımlılık söz konusu olduğunda bu göstergenin işlememesi riski var, çünkü elinizdeki denklem sisteminde her ne kadar &lt;span class="math"&gt;\(p {\ge} m\)&lt;/span&gt; tutuyor olsa da bağımlı denklemler tek bir denklem olarak temsil edilebildiği için &lt;span class="math"&gt;\(p {\le} m\)&lt;/span&gt; riski var.
Bu riskin oluşmaması için kontrol etmemiz gereken, A dizeyinin sütun alanının "m" boyutunda bir bağımsız denklemler kümesini barındırıp barındırmadığı.
"m" boytundaki bir denklemler kümesinin "m" taneden daha fazla bağımsız denkleme sahip olamayacağı düşünülürse, zira hiçbir denklem bir diğeri cinsinden yazılamayacaktır, A dizeyinin u yöneyi bağlamında yukarıdaki şartları sağlayabilmesi için, m üzerinden birimlenen bir bağımsız denklemler kümesini barındırması gerektiği aşikardır.
Kaç tane "m" kadar barındıracağı sorun değil, ancak bir veya daha fazla "m" boyutlu küme barındırması şart.&lt;/p&gt;
&lt;p&gt;Sorumuzun diğer ayağına gelelim, &lt;span class="math"&gt;\(Ak=u\)&lt;/span&gt; denklem sistemini &lt;span class="math"&gt;\(A^{-1}\)&lt;/span&gt; ile çözmeye çalıştığımı yazmıştım.
Ters dizeyi bir önceki yazılardan hatırlayanlar, onun düzüyle çarpıldığında birim dizeyi verdiğini hatırlayacaklardır.
Birim dizeyin temel şartı olan kendisiyle çarpılanı değiştirmeme özelliğinin temel dayanağı olan kare şeklinde olmayı, yani satır sayısının sütun sayısına eşit olmasını da hatırlayalım.
Bu bağlamda belki de en başta söylememiz gereken en bariz olgu şuydu, A dizeyi eğer ters dizey ile çözülebiliyorsa, kare şeklindedir, yani &lt;span class="math"&gt;\(p {\ge} m\)&lt;/span&gt; filan demeye gerek kalmadan, baştan &lt;span class="math"&gt;\(p = m\)&lt;/span&gt; olmak durumundadır arkadaşlar da diyebilirdim.
Takip ettiğim kaynak &lt;a class="footnote-reference" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-6/#id2" id="id1"&gt;[1]&lt;/a&gt; bunu bu şekilde sunmuyor, yani bunu başta sunmuyor ki iyi de yapıyor aslında, çünkü mantıken denklemin kendisinin çözülebilme şartlarının denklemin bir yöntemle çözülebilme şartına öncelenmesi gerekir.&lt;/p&gt;
&lt;p&gt;O halde soruya tam yanıt verelim.&lt;/p&gt;
&lt;p&gt;Soru şuydu:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Ak=u\)&lt;/span&gt; denklem sistemi hangi durumlarda &lt;span class="math"&gt;\(A^{-1}\)&lt;/span&gt; ile çözülebilir ?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cevabıysa şu:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Eğer A'nın satır ve sütun sayısı birbirine eşitse ve sütunlarını oluşturan yöneyler doğrusal bağımsızlık şartını sağlıyorsa, &lt;span class="math"&gt;\(Ak=u\)&lt;/span&gt; denklem sistemi &lt;span class="math"&gt;\(A^{-1}\)&lt;/span&gt; ile çözülebilir.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bu yazıyı burada bitiriyorum.
Doğrusal Cebir üzerine olan yazı dizisinin bir sonraki yazısı, yöney normları, üzerine olacak.
Eklemek istediğiniz bir şey varsa, ya da daha iyi açıklanmasını talep ettiğiniz bir şey lütfen yorumlarda belirtin.&lt;/p&gt;
&lt;p&gt;Sağlıcakla,&lt;/p&gt;
&lt;p&gt;Kaan&lt;/p&gt;
&lt;!-- deep learning p., 38 --&gt;
&lt;table class="docutils footnote" frame="void" id="id2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-6/#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Kaynağı önceki yazılarımda sıkça belirttim. Goodfellow I.,Y. Bengio, Deep Learning, Cambridge, 2016.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/div&gt;</description><category>doğrusal cebir</category><category>makine öğrenimi</category><category>mathjax</category><category>yapay-zeka</category><guid>https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-6/</guid><pubDate>Tue, 04 Jul 2017 00:25:17 GMT</pubDate></item><item><title>Makine Öğrenimine Hazırlık 2.1 Doğrusal Cebir 5</title><link>https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/</link><dc:creator>Kaan Eraslan</dc:creator><description>&lt;div&gt;&lt;p&gt;Merhaba Arkadaşlar,&lt;/p&gt;
&lt;div class="contents topic" id="contents"&gt;
&lt;p class="topic-title first"&gt;Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/#dogrusal-bagimlilik-2" id="id3"&gt;Doğrusal Bağımlılık - 2&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/#dogrusal-bilesim" id="id4"&gt;Doğrusal Bileşim&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/#katsayi-dizeyi" id="id5"&gt;Katsayı dizeyi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/#dogrusal-aralik" id="id6"&gt;Doğrusal Aralık&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/#bonus" id="id7"&gt;Bonus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/#notlar" id="id8"&gt;Notlar&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;Makine Öğrenimine Hazırlık yazı dizisinin doğrusal bağımlılık ile ilgili son yazısıyla karşınızdayım
Bildiğiniz gibi bu yazı dizisini aslında makine öğreniminde ve daha sonrasında derin öğrenimde karşımıza çıkacak algoritmaların matematiksel temellerini anlayabilmemiz için yazıyorum.
Bir &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-4/"&gt;önceki yazımda&lt;/a&gt; doğrusal bağımlılık konusunun anlaşılabilmesi için gerekli olan doğru denklemi ve doğru sistemi konularını ele almıştım.
Eğer makine öğrenimine yeni başlıyorsanız, bu yazı dizisinin &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-1/"&gt;ilk bölümünden&lt;/a&gt; başlamanızı tavsiye ederim.
Eğer çok çok yeniyseniz ve "Makine Öğrenimi Nedir, Derin Öğrenim Nedir ?", gibi sorulara cevap bulmaya geldiyseniz, bunun için üç bölümlük bu konulara değinen &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/"&gt;ilk yazı dizisini&lt;/a&gt; tavsiye ederim.&lt;/p&gt;
&lt;p&gt;Bu yazı, doğrusal bağımlılık konusunun ikinci ve son bölümünü oluşturuyor.
Temel sorumuz şuydu, &lt;span class="math"&gt;\(Ak=u\)&lt;/span&gt; denklem sistemi hangi durumlarda &lt;span class="math"&gt;\(A^{-1}\)&lt;/span&gt; ile çözülebilir ?
Ele alacağımız kavramlar şunlar:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Doğrusal bileşim,&lt;/li&gt;
&lt;li&gt;Katsayı dizeyi&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ve en nihayetinde&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Doğrusal Bağımlılık&lt;/li&gt;
&lt;li&gt;Doğrusal Bağımsızlık&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="dogrusal-bagimlilik-2"&gt;
&lt;h2&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/#dogrusal-bagimlilik-2"&gt;Doğrusal Bağımlılık - 2&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="dogrusal-bilesim"&gt;
&lt;h3&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/#dogrusal-bilesim"&gt;Doğrusal Bileşim&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Bir doğru sistemini ifade eden denklemi düşünelim, &lt;span class="math"&gt;\(Ak=u\)&lt;/span&gt;.
Denklemde &lt;span class="math"&gt;\(A{\in}{\mathbb{R}}^{mxp}\)&lt;/span&gt;, A bir &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-1/#dizeyler"&gt;dizey&lt;/a&gt;; &lt;span class="math"&gt;\(k{\in}{\mathbb{R}^p}\)&lt;/span&gt;, k &lt;em&gt;bilinmeyen&lt;/em&gt; bir &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-1/#yoneyler"&gt;yöney&lt;/a&gt;; &lt;span class="math"&gt;\(u{\in}{\mathbb{R}^p}\)&lt;/span&gt;, u &lt;em&gt;bilinen&lt;/em&gt; bir yöneydir.&lt;/p&gt;
&lt;p&gt;Doğrusal bileşim dediğimiz işlem aslında bir yöneyin bir dizey ile çarpılması eyleminin adıdır.
Matematiksel ifadesi şu şekilde:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{:,1}k_1 + {\dots} + A_{:,n}k_n
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Okunuşu kısaca A dizeyinin &lt;strong&gt;sütunlarıyla&lt;/strong&gt; "k" yöneyinin elemanlarını çarpıyoruz.
Dolayısıyla aslında bütün ifade A dizeyinin sütunlarını oluşturan yöneylerin, k yöneyinin elemanlarını oluşturan sayıllarla çarpıldıktan sonra toplanmasını ifade ediyor.&lt;/p&gt;
&lt;p&gt;Burada k yöneyinin elemanlarına &lt;em&gt;katsayılar&lt;/em&gt; deniyor.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="katsayi-dizeyi"&gt;
&lt;h3&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/#katsayi-dizeyi"&gt;Katsayı dizeyi&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Şu ikisini karıştırmamak lazım.
Doğrusal bileşim bağlamında "k" yöneyinin elemanlarına katsayılar deniyor, ancak &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-4/#dogru-denklem-sistemi"&gt;doğrusal denklem sistemi&lt;/a&gt; bağlamında katsayı dizeyi, "A"'ya tekabül ediyor.
Somut olması için açık bir örnek vereyim:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
4x + 5y - z = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
2x + y - z = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Bir önceki yazıdaki denklem sistemini ele alalım.
Bu sistem bağlamında, katsayı dizeyi G diyelim.
G dizeyini açık yazalım:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
G = \left[
\begin{array}{r,r,r}
4, 5, -1 \\
2, 1, -1 \\
\end{array}
\right]
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Doğrusal bileşim bağlamında katsayıları oluşturan yöneye f diyelim.
f'yi açık yazalım:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
f = \left(
\begin{array}{r}
x \\
y \\
z \\
\end{array}
\right)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Şimdi doğrusal bileşim bağlamında katsayıların neler olduğunu açıkça gördüğümüze göre, doğrusal bağımlılık ve bağımsızlıktan bahsetmeye başlayabiliriz.
Eğer doğrusal denklem sistemindeki katsayı dizeyini oluşturan sütunlarla çarpılacak yöney elemanlarından herhangi biri 0'dan başka bir sayıysa, katsayı dizeyinin sütunları &lt;strong&gt;doğrusal bağımlılık&lt;/strong&gt; gösterirler.
Eğer çarpılacak yöney elemanlarının hepsi 0'a eşitse, katsayı dizeyinin sütunları &lt;strong&gt;doğrusal bağımsızlık&lt;/strong&gt; gösterirler.&lt;/p&gt;
&lt;p&gt;Doğrusal bağımsızlığın matematiksel ifadesi kolay anlaşılır.
Bu yüzden onu &lt;span class="math"&gt;\(Ak=u\)&lt;/span&gt; denklemi çerçevesinde veriyorum:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{:,1}k_1 + {\dots} + A_{:,n}k_n = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
k_i = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
{\forall}i = 1, {\dots}, n
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Kısaca &lt;span class="math"&gt;\(Ak=u\)&lt;/span&gt; denklem sisteminde eğer "k"nın bütün elemanları 0'a eşitse, A dizeyinin sütunları birbirinden doğrusal olarak bağımsızdır.
Eğer "k"'nın bir tane elemanı bile 0'a eşit değilse, A dizeyinin sütunları birbirine doğrusal olarak bağımlıdır.&lt;/p&gt;
&lt;p&gt;Neden ? Çünkü eğer "k" yöneyinin elemanlarından bir tanesi bile 0'a eşit değilse, A dizeyinin sütunlarından en azından biri, diğerinin doğrusal bileşimi demektir.
Neden ? Çünkü "k"'nın 0'a eşit olan elemanının çarpıldığı sütun ile, "k"'nın 0'a eşit olmayan elemanın çarpıldığı sütun arasında bir sayıl ile ifade edilebilecek bir ilişki var demektir.
Yukarıda tarifini verdiğimiz gibi yöney elemanlarını oluşturan sayılların sütun yöneyleriyle çarpımına doğrusal bileşim dendiği düşünülürse, "k"'nın ilgili elemanlarıyla çarpılan sütun yöneyleri doğrusal bileşim olarak yazılabilir.&lt;/p&gt;
&lt;p&gt;Biraz soyut kaldığını tahmin ediyorum ama örnekle daha iyi anlaşılacak.&lt;/p&gt;
&lt;p&gt;Yukarıdaki denklem sistemimizi ve ilgili çözümlerini alalım tekrar.
Ele aldığımız denklem sistemi doğrusal bağımlılığa bir örnek:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
4x + 5y - z = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
2x + y - z = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
s^T = \left(
\begin{array}{c}
x \\
y \\
z \\
\end{array}
\right)
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
s^T = \left(
\begin{array}{c}
-2 \\
1 \\
-3 \\
\end{array}
\right)
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}

G = \left[
\begin{array}{c,c,c}
4, 5, -1 \\
2, 1, -1 \\
\end{array}
\right]
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
G {\cdot} s = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left(
\begin{array}{c}
4 \\
2 \\
\end{array}
\right){\times}-2 +
\left(
\begin{array}{c}
5 \\
1 \\
\end{array}
\right){\times}1 +
\left(
\begin{array}{c}
-1 \\
-1 \\
\end{array}
\right){\times}-3 = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Durum buyken, doğrusal bağımlılık için şu soruyu soruyoruz "Acaba bir yöneyi diğerinin katı olarak yazabilir miyim ?" Yani hangi koşullarda:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
G_{:,1}s_1 = G_{:,2}s_2
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Geçerli bir ifadedir ? Buna verilen cevap, &lt;span class="math"&gt;\(\{ s_1, s_2 \} \not = \{ 0,0 \}\)&lt;/span&gt; gerek şartı sağlanıyorsa, ifade geçerli olabilir.
Neden ? Çünkü sütun yöneylerinin değerleri elveriyorsa bu ifade geçerli olacaktır.
Yukarıda verdiğim denklem sistemi, gerek şartı sağlıyor, olmasına rağmen bağımlılık şartını sağlamıyor. Görelim:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
s_2 \not = 0 \Rightarrow G_{:,1} = G_{:,2}{\frac{s_1}{s_2}}
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
s_1 \not = 0 \Rightarrow G_{:,1} = G_{:,2}{\frac{s_2}{s_1}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Uygulanabiliyor mu görelim:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left(
\begin{array}{c}
4 \\
2 \\
\end{array}
\right){\times}-2 = ?
\left(
\begin{array}{c}
5 \\
1 \\
\end{array}
\right){\times}1
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left(
\begin{array}{c}
4 \\
2 \\
\end{array}
\right) \not = - \frac{1}{2} \left(
\begin{array}{c}
5 \\
1 \\
\end{array}
\right)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Açıkça uygulanamıyor, o halde bir de uygulanabilen bir denklem sistemi görelim:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
2x + 1y  = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
4x + 2y  = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
s^T = \left( x,y \right)
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
s^T = \left( -1,2 \right)
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
G = \left[
\begin{array}{c,c,c}
2, 1 \\
4, 2 \\
\end{array}
\right]
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
G {\cdot} s = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left(
\begin{array}{c}
2 \\
4 \\
\end{array}
\right){\times} -1 +
\left(
\begin{array}{c}
1 \\
2 \\
\end{array}
\right){\times}2 = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
G_{:,1}s_1 =? G_{:,2}s_2
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left(
\begin{array}{c}
4 \\
2 \\
\end{array}
\right){\times}1
=? \left(
\begin{array}{c}
1 \\
2 \\
\end{array}
\right){\times}2
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left(
\begin{array}{c}
4 {\times}1 \\
2 {\times}1  \\
\end{array}
\right)
=? \left(
\begin{array}{c}
1 {\times}2  \\
2 {\times}2  \\
\end{array}
\right)
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
\left(
\begin{array}{c}
4 \\
2 \\
\end{array}
\right) = \left(
\begin{array}{c}
4 \\
2 \\
\end{array}
\right)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Görüldüğü üzere geçerlilik doğrulanıyor. O halde buradaki iki sütun yöneyi arasında doğrusal bir bağımlılıktan söz edebiliriz.
Burada konuyu dizeyler üzerinden anlatıyor olmamın sebebi makine öğreniminde genellikle dizeyler bağlamında kullanılıyor olmasında.
Özellikle ağırlık dizeyi denilen dizey üzerinde yapılan işlemlerde kilit bir kavram olacak.&lt;/p&gt;
&lt;p&gt;Bu iki denklem sistemi arasındaki farkın gözle görülür olması için ikisinin de koordinat düzleminde nasıl gözüktüğünü görelim.&lt;/p&gt;
&lt;p&gt;Doğrusal Bağımsız:&lt;/p&gt;
&lt;img alt="/images/MÖ-Hazırlık-21/dogrusalBagimsiz.png" src="https://d-k-e.github.io/yapayzeka-eski-metinler/images/M%C3%96-Haz%C4%B1rl%C4%B1k-21/dogrusalBagimsiz.png"&gt;
&lt;p&gt;Doğrusal Bağımlı:&lt;/p&gt;
&lt;img alt="/images/MÖ-Hazırlık-21/dogrusalBagimli.png" src="https://d-k-e.github.io/yapayzeka-eski-metinler/images/M%C3%96-Haz%C4%B1rl%C4%B1k-21/dogrusalBagimli.png"&gt;
&lt;p&gt;Verdiğim örneklerden de görüleceği üzere aslında doğrusal bağımlılık gösteren denklemleri niteleyen yöneyler, aynı doğrunun birer parçası, doğrusal bağımlılık &lt;em&gt;göstermeyen&lt;/em&gt; denklemleri niteleyen yöneyler, kesişen ama aynı yönde olmayan doğrulara ait.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="dogrusal-aralik"&gt;
&lt;h3&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/#dogrusal-aralik"&gt;Doğrusal Aralık&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Bu aslında ayrı bir başlık gerektirmeyen bir kavram.
Bir denklem sisteminin katsayı dizeyinin sütunlarını oluşturan yöneylerle yapılan doğrusal bileşimlerin tümüne &lt;strong&gt;sütun alanı&lt;/strong&gt; denir.
Yer yer &lt;em&gt;doğrusal aralık&lt;/em&gt;, ya da kısaca &lt;em&gt;aralık&lt;/em&gt; olarak da ifade edilir.
Doğrusal aralık ifadesi genel olarak bir yöneyler kümesinin olası bütün doğrusal bileşimleri sonucuna denir.
Bizim ele aldığımız konu yalnızca katsayı dizeyinin sütunları bağlamında olduğundan &lt;em&gt;sütun alanı&lt;/em&gt; ifadesi bana daha uygun görünüyor.
Aralık sözcüğü aslında durumu çok iyi karşılamıyor, yayılım, veya içerim daha iyi karşılıyor.
Bunu örneği verdikten sonra daha iyi göreceksiniz diye umuyorum.&lt;/p&gt;
&lt;p&gt;Doğrusal Aralık için hızlıca bir örnek vereyim &lt;a class="footnote-reference" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/#id2" id="id1"&gt;[1]&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Diyelim ki Y bir yöney uzayı, A'da bu uzayın bir alt kümesi.
Eğer Y yöney uzayının her yöneyi, A'daki yöneylerin doğrusal bileşimi olarak yazılabiliyorsa, Y, A'nın doğrusal aralığındadır.
Matematiksel olarak ifade edecek olursak:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
A \subset Y
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
A = \{v_1, v_2, {\dots}, v_n \}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Eğer &lt;span class="math"&gt;\(Y = c_1v_1 + c_2v_2 + {\dots} + c_nv_n\)&lt;/span&gt; ise DAralık(A) = Y.&lt;/p&gt;
&lt;p&gt;Örneğin &lt;span class="math"&gt;\(v_1 = \{1, 0, 0 \}\)&lt;/span&gt; ve &lt;span class="math"&gt;\(v_2 = \{ 0, 1, 1 \}\)&lt;/span&gt; yöneylerinin doğrusal aralığını görelim.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
c_1v^{T}_1 + c_2v^{T}_2 = c_1 \left(
\begin{array}{c}
1 \\
0 \\
0 \\
\end{array}
\right) + \left(
\begin{array}{c}
0 \\
1 \\
1 \\
\end{array}
\right) = \left(
\begin{array}{c}
c_1 \\
c_2 \\
c_2 \\
\end{array}
\right)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Görüldüğü üzere &lt;span class="math"&gt;\(v_1\)&lt;/span&gt; ve &lt;span class="math"&gt;\(v_2\)&lt;/span&gt; yöneylerinin doğrusal aralığı &lt;span class="math"&gt;\({\mathbb{R}}^3\)&lt;/span&gt; kümesindeki ikinci ve üçüncü elemanı aynı olan yöneylerin tamamını kapsar.
Neden ? Çünkü bu şartı sağlayan bütün yöneyleri &lt;span class="math"&gt;\(v_1\)&lt;/span&gt; ve &lt;span class="math"&gt;\(v_2\)&lt;/span&gt; doğrusal bileşimi ile ifade edebilirsiniz.
Örneğin &lt;span class="math"&gt;\(v_5 = \{ 8, 10, 10 \}\)&lt;/span&gt; yöneyini ele alalım.
Görüldüğü üzere yukarıdaki şartı sağlayan bir yöney.
Bu yöneyin nasıl &lt;span class="math"&gt;\(v_1\)&lt;/span&gt; ve &lt;span class="math"&gt;\(v_2\)&lt;/span&gt; doğrusal bileşimi ile ifade edildiğini görelim:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
v_5^{T} = \left(
\begin{array}{c}
8 \\
10 \\
10 \\
\end{array}
\right) =  \left(
\begin{array}{c}
1 \\
0 \\
0 \\
\end{array}
\right) {\times} 8 + \left(
\begin{array}{c}
0 \\
1 \\
1 \\
\end{array}
\right) {\times} 10
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Bu haliyle bakıldığında &lt;span class="math"&gt;\(v_5\)&lt;/span&gt; yöneyinin örnekteki doğrusal bileşimin şekliyle örtüştüğü görülüyor.&lt;/p&gt;
&lt;div class="section" id="bonus"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/#id7"&gt;Bonus&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Ufak bir bonus olarak, grafikleri çizerken kullandığım kodu da burada paylaşıyorum:&lt;/p&gt;
&lt;pre class="code python"&gt;&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-1"&gt;&lt;/a&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-2"&gt;&lt;/a&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;plt&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-3"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;formula&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x_range&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-4"&gt;&lt;/a&gt;    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x_range&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-5"&gt;&lt;/a&gt;    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;formula&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-6"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-7"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-8"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Doğrusal Bağımlı&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-9"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-10"&gt;&lt;/a&gt;&lt;span class="n"&gt;graphX&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;graphY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'-2*x'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-11"&gt;&lt;/a&gt;&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;graphX&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;graphY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Doğrusal bağımlı"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-12"&gt;&lt;/a&gt;&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;legend&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-13"&gt;&lt;/a&gt;&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-14"&gt;&lt;/a&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-15"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# Doğrusal Bağımsız&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-16"&gt;&lt;/a&gt;&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-17"&gt;&lt;/a&gt;&lt;span class="n"&gt;graphX1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;graphY1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'(-2*2*x +3)/-1'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-18"&gt;&lt;/a&gt;&lt;span class="n"&gt;graphX&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;graphY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'(-2*4*x +3)/-5'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-19"&gt;&lt;/a&gt;&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;graphX&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;graphY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Doğrusal Bağımsız 1"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-20"&gt;&lt;/a&gt;&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;graphX1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;graphY1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Doğrusal Bağımsız 2"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-21"&gt;&lt;/a&gt;&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;legend&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;a name="rest_code_d40c2d173b4a4ec7b3baa7d313caea20-22"&gt;&lt;/a&gt;&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;Bu yazıyı burada bitiriyorum.
Bundan sonraki yazı şu zamana kadar anlata geldiğim kavramların tamamını barındırarak, yazının başında temel soru olarak addettiğim ve &lt;span class="math"&gt;\(Ak=u\)&lt;/span&gt; denklem sistemi hangi durumlarda &lt;span class="math"&gt;\(A^{-1}\)&lt;/span&gt; ile çözülebilir sorusuna bir yanıt vereceğim.
Sizin konuya eklemek istediğiniz bir şey varsa yorumlarda belirtin lütfen.&lt;/p&gt;
&lt;p&gt;Sağlıcakla,&lt;/p&gt;
&lt;p&gt;Kaan&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="notlar"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/#id8"&gt;Notlar&lt;/a&gt;&lt;/h4&gt;
&lt;table class="docutils footnote" frame="void" id="id2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Örneği aldığım &lt;a class="reference external" href="http://math.bard.edu/belk/math213s14/LinearCombinationsAndSpanRevised.pdf"&gt;site&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>doğrusal cebir</category><category>makine öğrenimi</category><category>mathjax</category><category>yapay-zeka</category><guid>https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-5/</guid><pubDate>Tue, 20 Jun 2017 01:33:17 GMT</pubDate></item><item><title>Makine Öğrenimine Hazırlık 2.1 Doğrusal Cebir 4</title><link>https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-4/</link><dc:creator>Kaan Eraslan</dc:creator><description>&lt;div&gt;&lt;p&gt;Merhaba Arkadaşlar&lt;/p&gt;
&lt;div class="contents topic" id="contents"&gt;
&lt;p class="topic-title first"&gt;Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-4/#dogrusal-bagimlilik-1" id="id3"&gt;Doğrusal Bağımlılık - 1&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-4/#dogru-denklemi" id="id4"&gt;Doğru Denklemi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-4/#dogru-denklem-sistemi" id="id5"&gt;Doğru Denklem Sistemi&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-4/#notlar" id="id6"&gt;Notlar&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;Makine Öğrenimine Hazırlık yazı dizisinin bir başka yazısı.
Bu yazı dizisini makine öğreniminde ve daha sonrasında derin öğrenimde karşımıza çıkacak algoritmaların matematiksel temellerini anlayabilmemiz için yazıyorum.
Bir &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-3/"&gt;önceki yazımda&lt;/a&gt; özellikle doğrusal sınıflayıcıların temeli niteliğindeki &lt;span class="math"&gt;\(Ak=u\)&lt;/span&gt; denklemini çözmeye yarayan matematiksel kavramlar olan ters dizey ve birim dizeyini açıklamıştım.
Eğer makine öğrenimine yeni başlıyorsanız, bu yazı dizisinin &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-1/"&gt;ilk bölümünden&lt;/a&gt; başlamanızı tavsiye ederim.
Eğer çok çok yeniyseniz ve "Makine Öğrenimi Nedir, Derin Öğrenim Nedir ?", gibi sorulara cevap bulmaya geldiyseniz, bunun için üç bölümlük bu konulara değinen &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/"&gt;ilk yazı dizisini&lt;/a&gt; tavsiye ederim.&lt;/p&gt;
&lt;p&gt;Bu yazı boyunca temelde Doğrusal Bağımlılık konusuna değinmek için gereken bir kaç kavrama değineceğim.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Doğrusal Bağımlılık
- Doğru denklemi
- Doğru denklem sistemi&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bunlar ana hattı belirliyor olmakla beraber aralarda yeni terimlere ve konulara baş vuracağız.
Neden bu konulardan bahsedeceğiz ?
Çünkü bir önceki yazıda ters dizey ve birim dizeyi aracılığıyla çözdüğümüz, yukarıda da belirttiğimiz denklemi.&lt;/p&gt;
&lt;div class="section" id="dogrusal-bagimlilik-1"&gt;
&lt;h2&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-4/#dogrusal-bagimlilik-1"&gt;Doğrusal Bağımlılık - 1&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Bir &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-3/"&gt;önceki yazıda&lt;/a&gt; &lt;span class="math"&gt;\(A^{-1}\)&lt;/span&gt; için sorduğum soru kenarda dursun.
Bu bölümde bu soruya yaklaşımımızı etkileyecek önemli bir dizi kavramı açıklamaya çalışacağım.
Doğrusal bağımlılığın ne olduğunu anlayabilmemiz bilmemiz gereken ilk şey, bir doğru denkleminin ne olduğu.&lt;/p&gt;
&lt;div class="section" id="dogru-denklemi"&gt;
&lt;h3&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-4/#dogru-denklemi"&gt;Doğru Denklemi&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Doğru denklemi, koordinat düzlemi üzerindeki bir doğruyu ifade eden denklemdir. Genel formülü şudur:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{i,:}k=u_i
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Tanıdık değil mi. Yukarıdaki denkleme çok benziyor. Bir örnek verecek olursak.
Diyelim ki A, 2x2 bir dizey, "k" 2 satırlı bir yöney, "u" da 2 satırlı bir yöney:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
A = \left[
\begin{array}{r,r}
3 &amp;amp; 4 \\
2 &amp;amp; 3 \\
\end{array}
\right]
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
k = \left(
\begin{array}{r}
x \\
y \\
\end{array}
\right)
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
u = \left(
\begin{array}{r}
2 \\
1 \\
\end{array}
\right)
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Verdiğimiz örnekler ışığında, bir doğrunun denklemi şu olacaktır:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
3x + 4y = 2
\end{equation*}
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="dogru-denklem-sistemi"&gt;
&lt;h3&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-4/#dogru-denklem-sistemi"&gt;Doğru Denklem Sistemi&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Doğru denklem sistemi ise birden fazla doğrudan oluşan ve aynı değişken yöneyini kullanandır.
Değişken yöneyinden kastım, yukarıdaki örnekteki "k" gibi, doğru denklemine değişkenlerini veren yöney.
Bu sistemler genelde &lt;span class="math"&gt;\(Ak=u\)&lt;/span&gt; şeklinde ifade edilirler.
Dikkat edilmesi gereken noktaysa, eğer &lt;span class="math"&gt;\(A^{mxp}\)&lt;/span&gt; ve &lt;span class="math"&gt;\(k^{1xp}\)&lt;/span&gt; ise &lt;span class="math"&gt;\(u^{1xp}\)&lt;/span&gt; olacaktır.
Bu genellemeyi açık yazacak olursak:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{1,1}k_1 + \dots + A_{1,p}k_p = u_1
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{2,1}k_1 + \dots + A_{2,p}k_p = u_2
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
\vdots
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{m,1}k_1 + \dots + A_{m,p}k_p = u_m
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Bir doğru denklem sisteminin &lt;strong&gt;türdeş&lt;/strong&gt; olması demek, "u" yöneyinin bütün elemanlarının 0 olması demektir.
Türdeş doğru sistemlerinin hep &lt;em&gt;en az bir&lt;/em&gt; çözümü vardır.
En az bir çözüm şartını sağlayan denklemlerin başında k yöneyinin sadece 0'lardan oluşması hali gelir.
Bu çözüme &lt;strong&gt;apaçık çözüm&lt;/strong&gt; denir.
Sistemdeki denklemlerden birinin çözümünü sağlayan ve sadece 0'lardan oluşmayan "k" yöneyinin sağladığı çözüme ise &lt;strong&gt;apaçık olmayan&lt;/strong&gt; çözüm denir.
Örneğin elinizde şöyle bir sistem olsun:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
4x + 5y - z = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
2x + y - z = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Bu denklemi çözmek için yapmamız gereken şey basit.
İkinci denklemi - 2 ile çarpıp birinci denkleme eklemek.
Bunun sonucunda elde edeceğimiz denklemse şu olacaktır:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
3y + z = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;İşin anlaşılması biraz güç, daha doğrusu niye yapıldığını anlamak biraz güç olan noktası burada.
Bu denklemdeki değişkenlerden birine 0'dan büyük bir değer veriyoruz. Neden ? Daha doğrusu neden 0'dan büyük keyfi bir değer vermemiz
herhangi bir problem yaratmıyor ?
Sebebi şu: Bir doğru denklem sistemi, kendisini dönüştüren eşitleme işlemlerinde sonuç kümesini muhafaza eder.&lt;/p&gt;
&lt;p&gt;Bunun ispatı biraz uzun ve doğrusal cebir işlemlerinden ziyade kümelerin özellikleriyle alakalı, ama karmaşık değil.
Ben burada işi tam yapmış olmak adına ispatı vereceğim &lt;a class="footnote-reference" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-4/#id2" id="id1"&gt;[1]&lt;/a&gt; .&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Doğru denklem sistemleri aslında birer denklem kümesi olduğundan, bu kümeye ait olan denklemlerin sırası, denklemleri çözen sonuçlar kümesini değiştirmiyor.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\({\alpha} \not = 0\)&lt;/span&gt; diyelim.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Elimizdeki &lt;span class="math"&gt;\(Ak=u\)&lt;/span&gt; sistemindeki, "i" denklemini &lt;span class="math"&gt;\({\alpha}\)&lt;/span&gt; ile çarpalım.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Anlaşılır olması için sistemi açık yazıyorum.&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{1,1}k_1 + \dots + A_{1,p}k_p = u_1
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{2,1}k_1 + \dots + A_{2,p}k_p = u_2
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
\vdots
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
{\alpha}A_{i,1}k_1 + \dots {\alpha}A_{i,p}k_p = {\alpha}u_i
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{m,1}k_1 + \dots + A_{m,p}k_p = u_m
\end{equation*}
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;S bu doğru sisteminin çözüm kümesi olsun, T de &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; ile çarpım sonucu dönüşmüş sistemin sonuç kümesi olsun.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;span class="math"&gt;\((k_1, k_2, k_3, \dots, k_p) = (f_1, f_2, f_3, \dots, f_p) \in S\)&lt;/span&gt;. Yani "k" ve "f" eşit yöneyler.&lt;/li&gt;
&lt;li&gt;Dolayısıyla &lt;span class="math"&gt;\({\alpha}A_{i,1}f_1 + \dots {\alpha}A_{i,p}f_p = {\alpha}u_i\)&lt;/span&gt; geçerlidir.&lt;/li&gt;
&lt;li&gt;Dolayısıyla &lt;span class="math"&gt;\((f_1, f_2, f_3, \dots, f_p) \in T\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;O halde &lt;span class="math"&gt;\(S \subset T\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;S bu doğru sisteminin çözüm kümesi olsun, T de &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; ile çarpım sonucu dönüşmüş sistemin sonuç kümesi olsun.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\((k_1, k_2, k_3, \dots, k_p) = (f_1, f_2, f_3, \dots, f_p) \in T\)&lt;/span&gt;. Yani "k" ve "f" eşit yöneyler.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Dolayısıyla &lt;span class="math"&gt;\(T_i = \{ {\alpha}A_{i,1}f_1 + \dots {\alpha}A_{i,p}f_p = {\alpha}u_i \}\)&lt;/span&gt; geçerlidir.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(\alpha \not = 0\)&lt;/span&gt; olduğundan dolayı, &lt;span class="math"&gt;\(\frac{1}{\alpha}T_i\)&lt;/span&gt;, geçerli bir sonuç verecektir.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Açık yazacak olursam:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
{\frac{1}{\alpha}}{\alpha}A_{i,1}k_1 + \dots {\frac{1}{\alpha}}{\alpha}A_{i,p}k_p = {\frac{1}{\alpha}}{\alpha}u_i
\end{equation*}
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Bu işlem geçerlidir.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;O halde &lt;span class="math"&gt;\(T \subset S\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;İki kümenin birbirine eşit olmasının şartı böylelikle sağlanmış oluyor.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;İspatın birinci ayağını bitirmiş olduk.
İlk dikkatimizi çekmesi gereken şey, eğer &lt;span class="math"&gt;\(\alpha = 0\)&lt;/span&gt; olsaydı, 1. ayağın 3. maddesini iddia edemezdik, zira &lt;span class="math"&gt;\(\frac{1}{0}\)&lt;/span&gt; ile karşılaşma imkanımız olurdu.&lt;/p&gt;
&lt;ol class="arabic" start="3"&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; herhangi bir karmaşık sayı olsun.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Elimizdeki &lt;span class="math"&gt;\(Ak=u\)&lt;/span&gt; sistemindeki, "i" denklemini &lt;span class="math"&gt;\({\alpha}\)&lt;/span&gt; ile çarpıp, "j" denklemine ekleyelim.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Açık yazacak olursam:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{1,1}k_1 + \dots + A_{1,p}k_p = u_1
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{2,1}k_1 + \dots + A_{2,p}k_p = u_2
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
\vdots
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
({\alpha}A_{i,1} + A_{j,1})k_1 + \dots ({\alpha}A_{i,p} + A_{j,p})k_p = {\alpha}u_i + u_j
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{m,1}k_1 + \dots + A_{m,p}k_p = u_m
\end{equation*}
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;S bu doğru sisteminin çözüm kümesi olsun, T dönüşmüş sistemin sonuç kümesi olsun.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\((k_1, k_2, k_3, \dots, k_p) = (f_1, f_2, f_3, \dots, f_p) \in S\)&lt;/span&gt;. Yani "k" ve "f" eşit yöneyler.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(T_j\)&lt;/span&gt; açık yazılınca şu görülecektir:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
({\alpha}A_{i,1} + A_{j,1})f_1 + \dots + ({\alpha}A_{i,p} + A_{j,p})f_p = {\alpha}u_i + u_j
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
({\alpha}A_{i,1}f_1 + \dots + {\alpha}A_{i,p}f_p) + (A_{j,1}f_1 + \dots + A_{j,p}f_p) = {\alpha}u_i + u_j
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
{\alpha}(A_{i,1}f_1 + \dots + A_{i,p}f_p) + (A_{j,1}f_1 + \dots + A_{j,p}f_p) = {\alpha}u_i + u_j
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
{\alpha}u_i + u_j = {\alpha}u_i + u_j
\end{equation*}
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Dolayısıyla &lt;span class="math"&gt;\((f_1, f_2, f_3, \dots, f_p) \in T\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;O halde &lt;span class="math"&gt;\(S \subset T\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;S bu doğru sisteminin çözüm kümesi olsun, T de &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; dönüşmüş sistemin sonuç kümesi olsun.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\((k_1, k_2, k_3, \dots, k_p) = (f_1, f_2, f_3, \dots, f_p) \in T\)&lt;/span&gt;. Yani "k" ve "f" eşit yöneyler.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;span class="math"&gt;\(T_j\)&lt;/span&gt; açık yazılınca şu görülecektir:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{j,1}f_1 + \dots + A_{j,p}f_p = A_{j,1}f_1 + \dots + A_{j,p}f_p + {\alpha}u_i - {\alpha}u_i
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{j,1}f_1 + \dots + A_{j,p}f_p = A_{j,1}f_1 + \dots + A_{j,p}f_p + {\alpha}(A_{i,1}f_1 + \dots + A_{i,p}f_p) - {\alpha}u_i
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{j,1}f_1 + \dots + A_{j,p}f_p = A_{j,1}f_1 + {\alpha}A_{i,1}f_1 + \dots + A_{j,p}f_p + {\alpha}A_{i,p}f_p - {\alpha}u_i
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{j,1}f_1 + \dots + A_{j,p}f_p = f_1(A_{j,1} + {\alpha}A_{i,1} ) + \dots + f_p(A_{i,p} + {\alpha}A_{i,p}) - {\alpha}u_i
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{j,1}f_1 + \dots + A_{j,p}f_p = {\alpha}u_i + u_j - {\alpha}u_i
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
A_{j,1}f_1 + \dots + A_{j,p}f_p =  u_j
\end{equation*}
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Dolayısıyla &lt;span class="math"&gt;\((f_1, f_2, f_3, \dots, f_p) \in S\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;O halde &lt;span class="math"&gt;\(T \subset S\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;İki kümenin birbirine eşit olmasının şartı böylelikle sağlanmış oluyor.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Neden ispatın ikinci ayağında &lt;span class="math"&gt;\(\alpha \not = 0\)&lt;/span&gt; şartını aramadık ?
Bu sorunun cevabı aslında 3.3.2 bölümündeki işlem dizisinden anlaşılıyor.
&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; değeri bu işlem dizisi boyunca bir önem teşkil etmiyor, zira kendisiyle herhangi bir işlem yapılmıyor.
Çarpma işleminin özellikleri çerçevesinde ifadenin tekrar yazılması sonucu, &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; konum değiştiriyor o kadar.&lt;/p&gt;
&lt;p&gt;Bu ispat ışığında yukarıda verdiğim denklem sisteminin çözümü sırasında kullandığım metodun meşruluğu görülüyor.
Denklemlerin birbirine eklenmesi ve onların 0'dan büyük sayılarla çarpılması çözüm kümesini yani "k" yöneyinin elemanlarını
değiştirmediğine göre, ve aradığım çözüm kümesinin tek şartı &lt;strong&gt;apaçık olmamak&lt;/strong&gt; olduğuna göre, denklemi çözmemizi sağlayacak ilk değerin sadece bu şartları sağlaması, denklem sisteminin çözülmesi için yeter neden teşkil eder.
Örneği çözerek bunu göstereyim:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
4x + 5y - z = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
2x + y - z = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
-2(2x + y - z) = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
4x -4x + 5y - 2y + (-z + 2z) = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
3y + z = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Diyelim ki &lt;span class="math"&gt;\(z=-3\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
3y - 3 = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
y = 1
\end{equation*}
&lt;/div&gt;
&lt;p&gt;O halde:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
2x + 1 - (-3) = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
2x + 4 = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
x = -2
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Peki bu değerler, ilk denklemi sağlıyorlar mı ? Görelim:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
4(-2) + 5(1) - (-3) = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
-8 + 5 + 3 = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
8 - 8 = 0
\end{equation*}
&lt;/div&gt;
&lt;div class="math"&gt;
\begin{equation*}
0 = 0
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Bu ispat ve onun uygulamasıyla bu yazıyı bitiriyorum.
Doğrusal Bağımlılık konusunun ikinci bölümünde, doğrusal bileşim, katsayı dizeyi, ve en nihayetinde doğrusal bağımlılık ve doğrusal bağımsızlık
konularını ele alarak, iki yazı boyunca süre gelmiş olan, &lt;span class="math"&gt;\(Ak=u\)&lt;/span&gt; denklem sistemi hangi durumlarda &lt;span class="math"&gt;\(A^{-1}\)&lt;/span&gt; ile çözülebilir sorusunu ele almak için gerekli olan kavramsal alt yapıyı tamamlamış olacağım.&lt;/p&gt;
&lt;p&gt;Sağlıcakla,&lt;/p&gt;
&lt;p&gt;Kaan&lt;/p&gt;
&lt;div class="section" id="notlar"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-4/#id6"&gt;Notlar&lt;/a&gt;&lt;/h4&gt;
&lt;table class="docutils footnote" frame="void" id="id2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-4/#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;İspatı aldığım &lt;a class="reference external" href="http://linear.ups.edu/html/section-SSLE.html"&gt;kaynak&lt;/a&gt; .&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>doğrusal cebir</category><category>mathjax</category><category>yapay-zeka</category><guid>https://d-k-e.github.io/yapayzeka-eski-metinler/posts/makine-ogrenimine-hazirlik-21-dogrusal-cebir-4/</guid><pubDate>Mon, 12 Jun 2017 21:07:43 GMT</pubDate></item><item><title>Yapay Zeka ve Derin Öğrenime Giriş 1.3</title><link>https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-13/</link><dc:creator>Kaan Eraslan</dc:creator><description>&lt;div&gt;&lt;p&gt;Merhaba Arkadaşlar,&lt;/p&gt;
&lt;p&gt;Bir &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-2/"&gt;önceki yazımda&lt;/a&gt; &lt;em&gt;Temsil Öğrenimi&lt;/em&gt; veya diğer bir adıyla &lt;em&gt;Nitelik Öğrenimi&lt;/em&gt; konusuna değinmiştim.
Otomatik kodlayıcıların aldıkları işlevlerden ve temsilde açığa çıkan değişiklik unsurlarıyla, gözlemlenenlerin ayrıştırıcı özellikleri arasındaki ilişkiden bahsetmiştim.
Ayrıştırıcı özelliklerin arasındaki karşılıklı etkileşim dolayısıyla temsil öğrenimindeki aşılması güç gözüken bir sorun olan değişiklik unsurlarının birbirinden ayrıştırılması işlemini açıklamaya çalıştım.&lt;/p&gt;
&lt;p&gt;Bu yazıda, önceki yazıda duyurduğum gibi &lt;em&gt;Derin Öğrenimin&lt;/em&gt; bahsettiğim kavramlarla ilişkisine ve yukarıda belirttiğim probleme nasıl bir çözüm getirdiğine değineceğim.
Bu giriş yazı dizisinin son yazısı olduğu için, kavramlarla aşina olmayanlar için serinin ilk iki yazısına da göz atmalarını tavsiye ederim, aksi takdirde bazı şeyler havada kalacaktır.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Derin Öğrenimin&lt;/em&gt; yaptığı karmaşık temsilleri daha basit temsiller cinsinden ifade etmeye çalışmaktır.
Örneğin, beyaz bir tahtaya çizilmiş bir üçgeni düşünelim.
Üçgene baktığımızda gördüğümüz önce beyazdan farklı olandır.
Sonrasında bu farklı olanın düz çizgilerden oluştuğunu fark ederiz.
Ardından bu düz çizgilerin köşeler oluşturduğunu fark ederiz.
Nihayetinde oluşan köşelerin sayısı bize üçgeni verir.
Bu işleyiş derin öğrenim sürecinde makinenin işleyişine benzerdir.
Makine başta imgecik değerlerinden, beyaz olmayanları gruplar.
Sonrasında gruplananların pozisyonlarını karşılaştırarak alarak onların kenar mı köşe mi olduğunu belirler.
Son olarak da köşe sayısını hesaplar ve ilgili köşe sayısına tekabül ettiği kendisine verilmiş sonucu size sunar.&lt;/p&gt;
&lt;p&gt;O halde fark etmiş olabileceğiniz üzere burada işleyen imgecik değerlerinde açıkça gözlemediğimiz 4-5 tane kavram var.
Siyah, beyaz, düz çizgi, kenar, köşe, köşe sayısı.
Siyahı, beyaz olmayan diyerek, ve imgecik değerlerindeki farklılıktan yakaladık diyelim.
Beyaz olmayan imgeciklerin düz bir çizgi oluşturduğunu ifade edebilmemiz için, bu imgeciklerin konumu hakkında bize yargı veren bir model olması lazım.
Bu açıkça görüldüğü üzere ne üçgenle ne de imgeciklerin kendisiyle doğrudan ilişkili bir yapı, sadece belirli konumlarda olanların düz olmaya tekabül ettiğini belirten bir model.
Bu modelin elimizdeki üçgen problemine uygulanışında modele sunulan imgeciklerin konumu, ancak salt model açısından bakıldığında konumu verilen araba tekerleği, havadaki uçaklar, ya da endoplazmik retikulumlarda olabilirdi.
Aynı durum kenar, köşe kavramları içinde geçerli, yani bunlar da üçgen mahsus olmayan, imgeciklerle de doğrudan bir bağlantısı olmayan kavramlar.
Eldeki örnekte düz çizgilerin başladıkları ve bittikleri yerler olarak tanımlanıyor olmalarında ne üçgene ne de imgeciklere mahsus bir durum var.
Buna karşın, köşe sayısı ve üçgen arasındaki ilişki bir hayli doğrudan. O kadar ki bunun üçgen üzerinden modellenmiş bir nitelik olduğu fark ediliyor.
Makine elimizdeki örnekte bahsettiğimiz aşamalardan geçerek ne yapmış oldu peki ?
Çok basit, modeller arasındaki bir hiyerarşiyi takip ederek, yani onların ilgilendiği değerlerin hesaplanışında bir öncelik sonralık ilişkisi güderek, örneğin, önce siyah-beyaz, sonra çizgi, sonra kenar-köşe, vs. gibi, ham veriden, yani imgeciklerden, yakalamak istediğimiz varlığın ayrıştırıcı özelliğini, üç köşeli olmak, buldu.&lt;/p&gt;
&lt;p&gt;Bu yaklaşımdaki esas nokta, farklı modeller tarafından hesaplanan sonuçların daha sonra kendilerine atıfta bulunulabilecek şekilde saklanmaları, bu sistemin kendi kendisini değerlendirebilmesini sağlayan yegane özellik.
Elimizdeki örnekte fark etmesi birazcık zor olmakla birlikte, diyelim ki ABC üçgeninin BC kenarının ortasında ufak bir boşluk var.
Silgi çarpmış, kolumuz değmiş, vs. herhangi bir şey olabilir.
Bu şartlar altında, üçgeni yakalamaya çalışan sistemimizin bu durumda çalışmaya devam etmesi, ve o boşluğu, kenarların ortasındaki boşluk olarak temsil edebilmesi lazım.
Modellerin sonuçlarının atıfta bulunulabilmesi burada devreye giriyor.
Elimizdeki örnekte makine diyelim ki düz çizgileri saptadı, ortaya açık bir şekil çıktı, dolayısıyla kenar diye bir şeyden söz edemememiz lazım.
Daha sonraki aşamada makine köşeleri ve köşe sayısını hesapladı ve şeklin üç köşe sayısı şartını sağladığını hesapladı.
Bu hesap ışığında makine, daha önceki model tarafından verilen açık şekil olmak sonucuna tekrar dönebilir, ve açıklık belirten değişiklik unsurunu, makineye daha öncesinden verdiğimiz talimatlar ışığında, görmezden gelebilir, veya bu sonucun kapsamını daraltabilir, yani örneğin şekil açıktır yerine çizgi bir nokta da kesilmiştir sonucunu sunabilir vs.&lt;/p&gt;
&lt;p&gt;Bu yöntemin derin öğrenim olarak ifade edilmesinin sebebi de, girdideki temsil ile çıktıdaki temsil arasında birbirinden görece bağımsız modeller tarafından üretilen temsillerin olması.
Derin Öğrenim algoritmalarını birer merdiven olarak da düşünebilirsiniz.
Her basamak aslında bir basamak, o basamağı bir başka basamağın üstüne ya da altına koyduğunuz için yukarıya ya da aşağıya doğru giden bir basamak. Kendi başına bıraksanız, yani merdivenden çıkarsanız basamağı ve yere koysanız, öyle ufak bir yükselti olur.&lt;/p&gt;
&lt;p&gt;Derin öğrenim modellerinin, derinlik ölçümü için kullanılan, temelde iki yaklaşım var.
Birincisi, bir derin öğrenim modelinin değerlendirilebilmesi için gerekli talimatların uzunluğu.
İkincisiyse, birbirleriyle ilişkilenen kavramların temsilini sunan çizgenin derinliği.
İlki hangi işlemin adım olarak sayılacağına göre değişiklik gösterir.
Kullandığımız modellerden birinin K-Ortalamalar Kümesi algoritması olduğunu düşünelim.
Bu algoritma bilindiği üzere aslında iki aşamalıdır: Merkezlere eleman tayin etme ve elemanların pozisyonlarını eniyileme.
Birinci kriter ışığında derinliğimiz bu iki aşamayı ayrı ayrı saymak ya da bu iki aşamayı aynı algoritmaya tabi olduğu için bir olarak saymak bağlamında değişiklik gösterecektir.
İkinci kriterle konuya yaklaşıldığı zamansa ortaya yukarıda üçgen için tarif ettiğim modele benzer bir model ortaya çıkıyor.
Elimizde, örneğin, düz çizgi, kenar, köşe gibi kavramlar var ve derinlik bunların birbiriyle olan ilişkilerini temsil eden çizgede gözleniyor.
Bu yaklaşımdaki dikkat edilmesi gereken noktaysa, kavramlar arasındaki ilişkilerden çıkan çizgedeki derinliğin, hesaplanma sürecini ifade eden çizgenin derinliğinden bir hayli farklı olması.&lt;/p&gt;
&lt;p&gt;Bu iki yaklaşımın ikisi de eşit derecede doğru ve geçerli, zira kişiler kendi modellerini kurgularken farklı birimleri temel alıyorlar.
Bir modelin derin olarak adlandırılabilmesi için de uzlaşılagelmiş bir ölçüm yok. O halde &lt;em&gt;Derin Öğrenim&lt;/em&gt; nedir ?
Tek cümleyle özetleyecek olursak, derin öğrenim, dünyayı içiçe geçmiş hiyerarşik temsiller şeklinde kurgulayarak karmaşık kavram ve temsilleri, daha basit kavram ve temsiller aracılığıyla hesaplayan, makine öğrenimi alanıdır.&lt;/p&gt;
&lt;p&gt;Bu yazıyı burada noktalıyorum ve böylelikle Derin Öğrenime Giriş serisini tamamlamış oluyorum.
Bundan sonraki seri, derin öğrenim algoritmalarını anlamak için olmazsa olmaz olan doğrusal cebir üzerine olacak.
Anlaşılmayan, ya da çok açık gözükmeyen noktaları lütfen yorumlarda belirtin.
Elimden geldiğince açıklamaya çalışırım.&lt;/p&gt;
&lt;p&gt;Sağlıcakla,&lt;/p&gt;
&lt;p&gt;Kaan&lt;/p&gt;&lt;/div&gt;</description><category>derin-öğrenim</category><category>makine öğrenimi</category><category>yapay-zeka</category><guid>https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-13/</guid><pubDate>Sun, 28 May 2017 01:52:32 GMT</pubDate></item><item><title>Yapay Zeka ve Derin Öğrenime Giriş - 1.1</title><link>https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/</link><dc:creator>Doğu Kaan Eraslan</dc:creator><description>&lt;div&gt;&lt;p&gt;Merhaba arkadaşlar,&lt;/p&gt;
&lt;div class="contents topic" id="contents"&gt;
&lt;p class="topic-title first"&gt;Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#terimler" id="id12"&gt;Terimler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#notlar" id="id13"&gt;Notlar&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;Bu yapay zeka ve derin öğrenim ile ilgili yazmaya başladığım serinin ilk bölümü. Temel olarak kullandığım kaynak &lt;a class="citation-reference" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#deeplearning2016" id="id1"&gt;[DeepLearning2016]&lt;/a&gt;. Bu bölümde:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
- Yapay zeka çalışmaları nedir ?
- Hangi sorunlara cevap vermeye çalışmaktadır ?
- İçindeki çalışma alanları nelerdir ?
&lt;/pre&gt;
&lt;p&gt;Gibi sorulara değineceğim. Sonraki yazılarda daha teknik konulara yer yer algoritmalara da gireceğim. Bu yazıda bahsettiğim konular, referans verdiğim kaynağın 1. bölümüne tekabül etmektedir.&lt;/p&gt;
&lt;p&gt;Yapay zeka esasen fark etme ve tanımlama sorunsalı üzerinden okunabilecek bir alan. Bir şeyleri 5 duyudan ve onları sentetize eden bir beyinden yoksun bir varlığa fark ettirme sorunsalı. Fark etmenin gerçekleşmesi içinde yapılması gerekense, fark edilecek şeyin duyusal içerikten bağımsız bir biçimde tanımlanması.&lt;/p&gt;
&lt;p&gt;Bilgisayarlar genel olarak, soyut kuralları takip etme işinde bizden daha iyiler. Bunun güzel bir örneği, bizden daha hızlı matematik işlemi yapabiliyor olmalarında, bir başka örneği yine bizden daha iyi satranç oynuyor olmalarında. Counter Strike vs gibi oyunlarla ilgilenen arkadaşların, internet kafede hedef botu kullanan adamı dövmesindeki sebepte yine bilgisayarın verili kuralları bizden daha iyi uygulayabiliyor olmasında.&lt;/p&gt;
&lt;p&gt;Ancak bilgisayarlar 5 duyu gerektiren işlerde açık ara kötüler. Örneğin soru sorana cevap verme, karşıdan karşıya geçerken gelen arabayı görüp durma vs gibi işleri beceremiyorlar, zira bu işler çok fazla farklı türden veriyi birbiriyle ilişkilendirmiş olarak zihnimizde barındırmamız sayesinde mümkün oluyor. Biz bu işleri otomatik yapıyoruz ve aslında ne kadar karmaşık bir ilişkiler ağının ürünü olduğunun genelde farkında değiliz. Çok fark etmeye başladığımız zaman da deliriyoruz zaten, ancak şu da bir gerçek ki bilgisayarın günlük hayatımızı gerçekten kolaylaştırabilmesi, büyük oranda bu cins işleri yapabilmesine bağlı. Yani siz dizi izlerken makinenin, akşam yemeği, ev temizliği, hatta ofis işlerinizin belirli bir bölümü gibi işlevleri gerçekleştirebilmesi için, bu 5 duyu gerektiren işlerde de sonuç alabilmeleri gerekiyor.&lt;/p&gt;
&lt;p&gt;İşte yapay zeka çalışmaları makinenin bu işleri yapabilmesini sağlayacak yöntemleri araştırıyor.
Denen yöntemlerden biri, makinenin dünyaya ilişkin bilmesi gereken her şeyi kodlamaya çalışmak, ki buna yapay zekaya bilgi temelli yaklaşım &lt;a class="footnote-reference" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#id8" id="id2"&gt;[1]&lt;/a&gt; deniyor. Siz bilgileri anlamsal içerikten yoksun bir dille ifade etmeye çalışıyorsunuz. Bilgisayarda genel mantık çerçevesinde dizayn edilmiş çıkarım kurallarını kullanarak, kendisine gelen bilgiden çıkarımlar yapıyor. Bu çok tutmadı, zira varolanı anlamdan yoksun bir dille ifade etmek hem bizim çok iyi yapamadığımız bir şey, hem de çok ağır işleyen bir süreç.&lt;/p&gt;
&lt;p&gt;Her şeyin el ile kodlanması gerektiği sistemlerde karşılaşılan güçlükler,bizi makinelerin ham haldeki veriden kendilerinin tekrar eden kalıpları çıkarsamasını sağlayacak sistemler yaratmaya yöneltti. Bu minvalden gelen çalışmalara da genel adıyla makine öğrenimi &lt;a class="footnote-reference" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#id9" id="id3"&gt;[2]&lt;/a&gt; alanında yapılan çalışmalar deniyor. Bu alanda yürütülen çalışmaların günlük hayattaki etkileri daha gözlemlenebilir durumda. Örneğin Naive Bayes algoritmasını kullanarak sahte e-postaları ayırt edebiliyoruz, ya da Doğrusal Bağlanımları kullanarak elimizdeki malzeme stoklarını ne zaman yenilememiz gerektiğine dair akıl yürütmeler yapabiliyoruz, veya Netflix gibi büyük şirketler çok basit K-Ortalamalar Kümesi gibi gruplama algoritmalarıyla sizin hangi filmlerden hoşlanabileceğiniz size sunuyorlar &lt;a class="citation-reference" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#algoritmalar" id="id4"&gt;[Algoritmalar]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Bu yaklaşım iyi hoş ama önemli bir sorunu var, o da verinin temsil &lt;a class="footnote-reference" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#id10" id="id5"&gt;[3]&lt;/a&gt; edilmesi gerekliliği. Yukarıda bahsettiğim algoritmaların işleyebilmesi için, verinin belirli işlemlerden geçmesi gerekiyor. Bu çok basit bir biçimde bir metni boşlukları kullanarak, kelimelere ayırmak olabileceği gibi, kelimelerin belge içindeki sıklığı kere kelimelerin içinde görüldüğü belge sayısının kesri, boyutlarından oluşan uzunluğu standartlaştırılmış belge yöneyleriyle kosünüs benzerliği hesapları yapmak gibi görece daha karmaşık işlemleri de kapsayabiliyor &lt;a class="citation-reference" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#tf-idf" id="id6"&gt;[TF-IDF]&lt;/a&gt;. İşlem görmüş ham veri içerisinde dikkate alınan her bir parçaya nitelik &lt;a class="footnote-reference" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#id11" id="id7"&gt;[4]&lt;/a&gt; deniyor. Yani ham veriye dair makinenin çıkarımlar yapabilmesini istiyorsanız onu bir nitelikler bütününe dönüştürmeniz lazım.&lt;/p&gt;
&lt;p&gt;Üzerinde çalıştığınız problemin gerektirdiği verilerin hangi özelliğinin çözüme ilişkin olduğunu ve bu özelliğin ne şekilde bir niteliğe dönüştürebileceğini saptamanız gerekiyor. Bu bir hayli meşakatli bir iş. Örneğin, elinizde 100 bin tane kırmızı ışıkta geçen araba resmi var. Bu arabalara ceza kesilebilmesi için, plakalarının fotoğraflarda ayrıştırılabilmesi gerekiyor. Bilgisayar için arabanın tamponu ile plakası arasında bir fark yok. İkisi de imgecik. Örneği ilgili terimlerle ifade edersek:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
- Problem: Işıktan geçen araba resminden plaka alma
- Özellik: Plaka: Beyaz bir dikdörtgen, üstünde siyahla yazılmış rakamlar ve sayılar var, bazılarında tire işareti de oluyor.
- Temsil: İmgecikler.
&lt;/pre&gt;
&lt;p&gt;Çözüm ne peki ? Temsilden özelliği türetmemizi sağlayacak nitelikleri ayrıştırmakta. Bunu nasıl yapacağız ? İşte makine öğreniminin temel sıkıntısı burada yatıyor.&lt;/p&gt;
&lt;p&gt;Bu yazıyı burada noktalıyorum, zira ara vermek için güzel bir nokta.
Bir &lt;a class="reference external" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-2/"&gt;sonraki yazımda&lt;/a&gt; &lt;em&gt;Temsil Öğrenimi&lt;/em&gt; ya da diğer bir adıyla &lt;em&gt;Nitelik Öğrenimini&lt;/em&gt; açıklamaya çalışacağım.
Çok katmanlı temsil gruplamalarından, değişiklik unsurlarından ve bunların öğrenimdeki rollerinden bahsedeceğim. Üçüncü yazımdaysa &lt;em&gt;Derin Öğrenimin&lt;/em&gt; bu bahsettiğim kavramlarla olan ilişkisine, ve &lt;em&gt;derinliğin&lt;/em&gt; nereden geldiğine değineceğim.&lt;/p&gt;
&lt;p&gt;Sağlıcakla,&lt;/p&gt;
&lt;p&gt;Kaan&lt;/p&gt;
&lt;div class="section" id="terimler"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#id12"&gt;Terimler&lt;/a&gt;&lt;/h2&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#id2"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Bilgi Temelli Yaklaşım: Makinenin dünyaya ilişkin bilmesi gereken her şeyi elle kodlamaya çalışmak.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#id3"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Makine Öğrenimi: Makinenin ham veriden tekrar eden kalıplar çıkarsaması.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#id5"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Temsil: Verinin sayısal ortamdaki hali.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#id7"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Nitelik: Temsilde bir özelliği ayrıştırmaya yarayan ölçülebilir yapı.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="notlar"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#id13"&gt;Notlar&lt;/a&gt;&lt;/h2&gt;
&lt;table class="docutils citation" frame="void" id="deeplearning2016" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#id1"&gt;[DeepLearning2016]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Goodfellow I.,Y. Bengio, Deep Learning, Cambridge, 2016.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="algoritmalar" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#id4"&gt;[Algoritmalar]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Bahsettiğim algoritmaları açıklayan yazılar da yayımlayacağım.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="tf-idf" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/#id6"&gt;[TF-IDF]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Kabaca tarifini yaptığım algoritmanın adı genellikle arama motorlarında kullanılan bir sıralama algoritması. İlk bölümü ts-tbs, açılımı, terim sıklığı-ters belge sıklığı algoritması (ingilizcesi t(erm) f(requency)-i(nverse) d(ocument) f(requency)), ikinci bölümüyse, kosünüs benzerliği. Bu ikisi arama motorlarındaki 'buna benzer sayfaları göster' gibi işlemlerin gerçekleşmesini sağlıyor. Bu algoritmayı açıklayan yazıları da ileride paylaşacağım.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>derin-öğrenim</category><category>makine öğrenimi</category><category>yapay-zeka</category><guid>https://d-k-e.github.io/yapayzeka-eski-metinler/posts/yapay-zeka-ve-derin-ogrenime-giris-1/</guid><pubDate>Fri, 26 May 2017 00:13:15 GMT</pubDate></item></channel></rss>